{"version":3,"sources":["webpack:///71b0297a54a4b6f1870d.worker.js","webpack:///webpack/bootstrap 71b0297a54a4b6f1870d","webpack:///./src/workers/sortBy.js","webpack:///./src/utils/CSVArrayController.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","CSVArrayController","onmessage","event","data","array","columnId","asc","arrayUtils","default","sortedArray","sortByColumn","postMessage","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","this","arguments","undefined","compareValues","val","val2","Set","size","isNaN","Number","localeCompare","slice","sort","searchString","pattern","RegExp","filter","row","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","column","search","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","rowColumn","err","return","_this","newArray","uniqueValuesSet","rowKey","add","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","uniqueKey","internalArray","push","groupedArray","map","newArayIndex","count","logEntryKey","logEntryColumnKey","parseInt"],"mappings":"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","file":"71b0297a54a4b6f1870d.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Worker file used for operatin of sorting the array.\n\t */\n\t\n\tconst CSVArrayController = __webpack_require__(1);\n\t\n\tonmessage = function(event) {\n\t    const data = event.data;\n\t\n\t    const array = data[0];\n\t    const columnId = data[1];\n\t    const asc = data[2];\n\t\n\t    const arrayUtils = new CSVArrayController.default(array);\n\t    const sortedArray = arrayUtils.sortByColumn(columnId, asc);\n\t\n\t    postMessage(sortedArray);\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* Class used to perform operations on array that has a CSV file loaded to it. */\n\tvar CSVArrayController = function () {\n\t  /**\n\t   * Create new instance for the particular array.\n\t   * @param {array} array Array with CSV entries in.\n\t   */\n\t  function CSVArrayController(array) {\n\t    _classCallCheck(this, CSVArrayController);\n\t\n\t    this.array = array;\n\t  }\n\t\n\t  /**\n\t   * Sort CSV array by values of a particular column.\n\t   * @param {number} columnId Column index that array will be sorted by.\n\t   * @param {boolean} asc If true array will be sorted by ascending order,\n\t   *                      otherwise descending order will be used.\n\t   * @returns {array} Sorted array.\n\t   */\n\t\n\t\n\t  _createClass(CSVArrayController, [{\n\t    key: 'sortByColumn',\n\t    value: function sortByColumn(columnId) {\n\t      var asc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t\n\t      /**\n\t       * Comparison function sort Array.prototype.sort().\n\t       * @param {*} val Value 1\n\t       * @param {*} val2 Value 2\n\t       * @returns {number}\n\t       */\n\t      var compareValues = function compareValues(val, val2) {\n\t        // Test for undefined values\n\t        if (val[columnId] === undefined && val2[columnId] === undefined) {\n\t          return 0;\n\t        } else if (val[columnId] !== undefined && val2[columnId] === undefined) {\n\t          return asc ? 1 : 0;\n\t        } else if (val[columnId] !== undefined && val2[columnId] === undefined) {\n\t          return asc ? 0 : 1;\n\t\n\t          // If value is a set, order it by size\n\t        } else if (val[columnId] instanceof Set || val2[columnId] instanceof Set) {\n\t          // If both values are sets, sort by size...\n\t          if (val[columnId] instanceof Set && val2[columnId] instanceof Set) {\n\t            if (asc) {\n\t              return val[columnId].size - val2[columnId].size;\n\t            } else {\n\t              return val2[columnId].size - val[columnId].size;\n\t            }\n\t\n\t            // Otherwise sets come first\n\t          } else if (val[columnId] instanceof Set && !(val2[columnId] instanceof Set)) {\n\t            return asc ? 1 : -1;\n\t          } else {\n\t            return asc ? -1 : 1;\n\t          }\n\t\n\t          // If both of the values are numbers\n\t        } else if (!isNaN(Number(val[columnId])) && !isNaN(Number(val2[columnId]))) {\n\t          if (asc) {\n\t            return Number(val[columnId]) - Number(val2[columnId]);\n\t          } else {\n\t            return Number(val2[columnId] - val[columnId]);\n\t          }\n\t          // If the value is a string.\n\t        } else if (typeof val[columnId] === 'string' || typeof val2[columnId] === 'string') {\n\t          if (typeof val[columnId] === 'string' && typeof val2[columnId] === 'string') {\n\t            if (asc) {\n\t              return val[columnId].localeCompare(val2[columnId]);\n\t            } else {\n\t              return val2[columnId].localeCompare(val[columnId]);\n\t            }\n\t          } else if (typeof val[columnId] === 'string' && typeof val2[columnId] !== 'string') {\n\t            return asc ? 1 : -1;\n\t          } else {\n\t            return asc ? -1 : 1;\n\t          }\n\t        }\n\t\n\t        return 0;\n\t      };\n\t\n\t      // Clone the array first, then sort.\n\t      return this.array.slice().sort(compareValues);\n\t    }\n\t\n\t    /**\n\t     * Search all the columns by the string provided.\n\t     * @param {string} searchString\n\t     * @returns {array} Array with entries that match the search string.\n\t     */\n\t\n\t  }, {\n\t    key: 'searchAllColumnsByString',\n\t    value: function searchAllColumnsByString(searchString) {\n\t      // TODO: Make sure that injecting string from user into regex is secure\n\t      var pattern = new RegExp(searchString, 'i');\n\t\n\t      return this.array.filter(function (row) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = row[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var column = _step.value;\n\t\n\t            // If string, just compare it with regex\n\t            if (typeof column === 'string' && column.search(pattern) !== -1) {\n\t              return true;\n\t\n\t              // If set, go through all the entries in the set\n\t            } else if (column instanceof Set) {\n\t              var _iteratorNormalCompletion2 = true;\n\t              var _didIteratorError2 = false;\n\t              var _iteratorError2 = undefined;\n\t\n\t              try {\n\t                for (var _iterator2 = column[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t                  var rowColumn = _step2.value;\n\t\n\t                  if (typeof rowColumn === 'string' && rowColumn.search(pattern) !== -1) {\n\t                    return true;\n\t                  }\n\t                }\n\t              } catch (err) {\n\t                _didIteratorError2 = true;\n\t                _iteratorError2 = err;\n\t              } finally {\n\t                try {\n\t                  if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t                    _iterator2.return();\n\t                  }\n\t                } finally {\n\t                  if (_didIteratorError2) {\n\t                    throw _iteratorError2;\n\t                  }\n\t                }\n\t              }\n\t            }\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t\n\t        return false;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Group the array by the value of column, something like GROUP BY in SQL.\n\t     * @description Merges the row into one for the values that are the same in\n\t     *              specified column, something like GROUP BY in SQL. It is very\n\t     *              expensive when the column contains a lot of unique values.\n\t     * @param {number} columnId Column array will be sorted by.\n\t     * @returns {array} Grouped array\n\t     */\n\t\n\t  }, {\n\t    key: 'groupByColumn',\n\t    value: function groupByColumn(columnId) {\n\t      var _this = this;\n\t\n\t      var newArray = [];\n\t      var uniqueValuesSet = new Set();\n\t\n\t      // Find unique entries in the group by column\n\t      for (var rowKey in this.array) {\n\t        uniqueValuesSet.add(this.array[rowKey][columnId]);\n\t      }\n\t\n\t      // Create empty array with empty unique keys\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = uniqueValuesSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var uniqueKey = _step3.value;\n\t\n\t          var internalArray = [];\n\t          internalArray[columnId] = uniqueKey;\n\t          newArray.push(internalArray);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t\n\t      var groupedArray = newArray.map(function (value, newArayIndex, array) {\n\t        var internalArray = [];\n\t        var count = 1;\n\t\n\t        // Go throught all the log entries\n\t        for (var logEntryKey in _this.array) {\n\t          // Match log entry with the same GROUP BY index\n\t          if (_this.array[logEntryKey][columnId] === value[columnId]) {\n\t            // Go through keys\n\t            for (var logEntryColumnKey in _this.array[logEntryKey]) {\n\t              // If it's the key that we group by...\n\t              if (parseInt(logEntryColumnKey, 10) === columnId) {\n\t                internalArray[logEntryColumnKey] = '' + _this.array[logEntryKey][logEntryColumnKey] + (' - COUNT(' + count + ')');\n\t                count++;\n\t                // Other keys\n\t              } else {\n\t                // No values in this column - assign the first value\n\t                if (!internalArray[logEntryColumnKey]) {\n\t                  internalArray[logEntryColumnKey] = _this.array[logEntryKey][logEntryColumnKey];\n\t\n\t                  // If it's a set of values, add it to the set - won't duplicate anyway\n\t                } else if (internalArray[logEntryColumnKey] instanceof Set) {\n\t                  internalArray[logEntryColumnKey].add(_this.array[logEntryKey][logEntryColumnKey]);\n\t\n\t                  // If the value insice the log entry is not the same, create a set to store all the different values\n\t                } else if (internalArray[logEntryColumnKey] !== _this.array[logEntryKey][logEntryColumnKey]) {\n\t                  internalArray[logEntryColumnKey] = new Set([internalArray[logEntryColumnKey]]);\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        return internalArray;\n\t      });\n\t\n\t      return groupedArray;\n\t    }\n\t  }]);\n\t\n\t  return CSVArrayController;\n\t}();\n\t\n\texports.default = CSVArrayController;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 71b0297a54a4b6f1870d.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 71b0297a54a4b6f1870d","/**\n * @file Worker file used for operatin of sorting the array.\n */\n\nconst CSVArrayController = require('../utils/CSVArrayController');\n\nonmessage = function(event) {\n    const data = event.data;\n\n    const array = data[0];\n    const columnId = data[1];\n    const asc = data[2];\n\n    const arrayUtils = new CSVArrayController.default(array);\n    const sortedArray = arrayUtils.sortByColumn(columnId, asc);\n\n    postMessage(sortedArray);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/eslint-loader!./src/workers/sortBy.js\n// module id = 0\n// module chunks = 0","/* Class used to perform operations on array that has a CSV file loaded to it. */\nexport default class CSVArrayController {\n  /**\n   * Create new instance for the particular array.\n   * @param {array} array Array with CSV entries in.\n   */\n  constructor(array) {\n    this.array = array;\n  }\n\n  /**\n   * Sort CSV array by values of a particular column.\n   * @param {number} columnId Column index that array will be sorted by.\n   * @param {boolean} asc If true array will be sorted by ascending order,\n   *                      otherwise descending order will be used.\n   * @returns {array} Sorted array.\n   */\n  sortByColumn(columnId, asc = true) {\n\n    /**\n     * Comparison function sort Array.prototype.sort().\n     * @param {*} val Value 1\n     * @param {*} val2 Value 2\n     * @returns {number}\n     */\n    const compareValues = (val, val2) => {\n      // Test for undefined values\n      if (val[columnId] === undefined && val2[columnId] === undefined) {\n        return 0;\n      } else if (val[columnId] !== undefined && val2[columnId] === undefined) {\n        return asc ? 1 : 0;\n      } else if (val[columnId] !== undefined && val2[columnId] === undefined) {\n        return asc ? 0 : 1;\n\n      // If value is a set, order it by size\n      } else if (val[columnId] instanceof Set || val2[columnId] instanceof Set) {\n        // If both values are sets, sort by size...\n        if (val[columnId] instanceof Set && val2[columnId] instanceof Set) {\n          if (asc) {\n            return val[columnId].size - val2[columnId].size;\n          } else {\n            return val2[columnId].size - val[columnId].size;\n          }\n        \n        // Otherwise sets come first\n        } else if (val[columnId] instanceof Set && !(val2[columnId] instanceof Set)) {\n          return asc ? 1 : -1;\n        } else {\n          return asc ? -1 : 1;\n        }\n\n      // If both of the values are numbers\n      } else if (!isNaN(Number(val[columnId])) && !isNaN(Number(val2[columnId]))) {\n        if (asc) {\n          return Number(val[columnId]) - Number(val2[columnId]);\n        } else {\n          return Number(val2[columnId] - val[columnId]);\n        }\n      // If the value is a string.\n      } else if (typeof val[columnId] === 'string' || typeof val2[columnId] === 'string') {\n        if (typeof val[columnId] === 'string' && typeof val2[columnId] === 'string') {\n          if (asc) {\n            return val[columnId].localeCompare(val2[columnId]);\n          } else {\n            return val2[columnId].localeCompare(val[columnId]);\n          }\n        } else if (typeof val[columnId] === 'string' && typeof val2[columnId] !== 'string') {\n          return asc ? 1 : -1;\n        } else {\n          return asc ? -1 : 1;\n        }\n      }\n\n      return 0;\n    };\n\n    // Clone the array first, then sort.\n    return this.array.slice().sort(compareValues);\n  }\n\n  /**\n   * Search all the columns by the string provided.\n   * @param {string} searchString\n   * @returns {array} Array with entries that match the search string.\n   */\n  searchAllColumnsByString(searchString) {\n    // TODO: Make sure that injecting string from user into regex is secure\n    const pattern = new RegExp(searchString, 'i');\n\n    return this.array.filter(row => {\n      for (let column of row) {\n        // If string, just compare it with regex\n        if (typeof column === 'string' && column.search(pattern) !== -1) {\n          return true;\n        \n        // If set, go through all the entries in the set\n        } else if (column instanceof Set) {\n          for (let rowColumn of column) {\n            if (typeof rowColumn === 'string' && rowColumn.search(pattern) !== -1) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Group the array by the value of column, something like GROUP BY in SQL.\n   * @description Merges the row into one for the values that are the same in\n   *              specified column, something like GROUP BY in SQL. It is very\n   *              expensive when the column contains a lot of unique values.\n   * @param {number} columnId Column array will be sorted by.\n   * @returns {array} Grouped array\n   */\n  groupByColumn(columnId) {\n    const newArray = [];\n    const uniqueValuesSet = new Set();\n\n    // Find unique entries in the group by column\n    for (let rowKey in this.array) {\n      uniqueValuesSet.add(this.array[rowKey][columnId]);\n    }\n\n    // Create empty array with empty unique keys\n    for (let uniqueKey of uniqueValuesSet) {\n      const internalArray = [];\n      internalArray[columnId] = uniqueKey;\n      newArray.push(internalArray);\n    }\n\n    const groupedArray = newArray.map((value, newArayIndex, array) => {\n      const internalArray = [];\n      let count = 1;\n\n      // Go throught all the log entries\n      for (let logEntryKey in this.array) {\n        // Match log entry with the same GROUP BY index\n        if (this.array[logEntryKey][columnId] === value[columnId]) {\n          // Go through keys\n          for (let logEntryColumnKey in this.array[logEntryKey]) {\n            // If it's the key that we group by...\n            if (parseInt(logEntryColumnKey, 10) === columnId) {\n              internalArray[logEntryColumnKey] = `${this.array[logEntryKey][logEntryColumnKey]}`\n                + ` - COUNT(${count})`;\n              count++;\n              // Other keys\n            } else {\n              // No values in this column - assign the first value\n              if (!internalArray[logEntryColumnKey]) {\n                internalArray[logEntryColumnKey] = this.array[logEntryKey][logEntryColumnKey];\n\n                // If it's a set of values, add it to the set - won't duplicate anyway\n              } else if (internalArray[logEntryColumnKey] instanceof Set) {\n                internalArray[logEntryColumnKey].add(\n                  this.array[logEntryKey][logEntryColumnKey]\n                );\n\n                // If the value insice the log entry is not the same, create a set to store all the different values\n              } else if (\n                internalArray[logEntryColumnKey] !== this.array[logEntryKey][logEntryColumnKey]\n              ) {\n                internalArray[logEntryColumnKey] = new Set([internalArray[logEntryColumnKey]]);\n              }\n            }\n          }\n        }\n      }\n\n      return internalArray;\n    });\n\n    return groupedArray;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/CSVArrayController.js"],"sourceRoot":""}